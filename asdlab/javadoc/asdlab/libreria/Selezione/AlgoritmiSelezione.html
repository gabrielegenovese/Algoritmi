<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_07) on Tue Apr 17 10:32:36 CEST 2007 -->
<TITLE>
AlgoritmiSelezione
</TITLE>

<META NAME="keywords" CONTENT="asdlab.libreria.Selezione.AlgoritmiSelezione class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="AlgoritmiSelezione";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AlgoritmiSelezione.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?asdlab/libreria/Selezione/AlgoritmiSelezione.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="AlgoritmiSelezione.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
asdlab.libreria.Selezione</FONT>
<BR>
Class AlgoritmiSelezione</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>asdlab.libreria.Selezione.AlgoritmiSelezione</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>AlgoritmiSelezione</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
La classe <code>AlgoritmiSelezione</code> contiene l'implementazione di numerosi
 algoritmi per la risoluzione di problemi di selezione e statistiche d'ordine.<br>
 Tutte le implementazioni proposte assumono che l'input sia costituito da un array i cui
 elementi implementano l'interfaccia standard <code>Comparable</code>.
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../asdlab/libreria/Selezione/AlgoritmiSelezione.html#AlgoritmiSelezione()">AlgoritmiSelezione</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Selezione/AlgoritmiSelezione.html#deleteMin(java.lang.Comparable[], int)">deleteMin</A></B>(java.lang.Comparable[]&nbsp;S,
          int&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rimuove l'elemento con chiave minima attualmente presente nell'heap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;java.lang.Comparable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Selezione/AlgoritmiSelezione.html#findMin(java.lang.Comparable[])">findMin</A></B>(java.lang.Comparable[]&nbsp;S)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'elemento di chiave minima attualmente custodito nell'heap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Selezione/AlgoritmiSelezione.html#fixHeap(java.lang.Comparable[], int, int)">fixHeap</A></B>(java.lang.Comparable[]&nbsp;S,
        int&nbsp;c,
        int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ripristina la propriet&agrave; di ordinamento di un heap rispetto
 ad un nodo di indice <code>i</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Selezione/AlgoritmiSelezione.html#heapify(java.lang.Comparable[], int, int)">heapify</A></B>(java.lang.Comparable[]&nbsp;S,
        int&nbsp;n,
        int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trasforma in heap un array di elementi a partire da un elemento
 di indice <code>i</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Comparable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Selezione/AlgoritmiSelezione.html#heapSelect(java.lang.Comparable[], int)">heapSelect</A></B>(java.lang.Comparable[]&nbsp;A,
           int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Seleziona l'elemento di ordine k dall'array di input mediante
 l'uso di un heap (<font color=red>Tempo O(n + k&middot;log(n))</font>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;java.lang.Comparable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Selezione/AlgoritmiSelezione.html#med3(java.lang.Comparable[], int)">med3</A></B>(java.lang.Comparable[]&nbsp;A,
     int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'elemento mediano di una sottosequenza di lunghezza 3
 della sequenza di input utilizzando due confronti.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;java.lang.Comparable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Selezione/AlgoritmiSelezione.html#med4(java.lang.Comparable[], int)">med4</A></B>(java.lang.Comparable[]&nbsp;A,
     int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'elemento mediano di una sottosequenza di lunghezza 4
 della sequenza di input utilizzando al pi&ugrave; tre confronti.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;java.lang.Comparable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Selezione/AlgoritmiSelezione.html#med5(java.lang.Comparable[], int)">med5</A></B>(java.lang.Comparable[]&nbsp;A,
     int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'elemento mediano di una sottosequenza di lunghezza 5
 della sequenza di input utilizzando al pi&ugrave; sei confronti.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Comparable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Selezione/AlgoritmiSelezione.html#minimo(java.lang.Comparable[])">minimo</A></B>(java.lang.Comparable[]&nbsp;A)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'elemento di chiave minima tra quelli appartenenti
 alla sequenza di input (<font color=red>Tempo O(n)</font>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Selezione/AlgoritmiSelezione.html#partition(java.lang.Comparable[], int, int)">partition</A></B>(java.lang.Comparable[]&nbsp;A,
          int&nbsp;i,
          int&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Partiziona <em>in loco</em> gli elementi di una sequenza di input in due sottosequenze
 nelle quali tutti gli elementi della prima sottosequenza sono pi&ugrave; piccoli di
 tutti gli elementi della seconda sottosequenza.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Selezione/AlgoritmiSelezione.html#partition(java.lang.Comparable[], int, int, int)">partition</A></B>(java.lang.Comparable[]&nbsp;A,
          int&nbsp;i,
          int&nbsp;f,
          int&nbsp;pos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Partiziona <em>in loco</em> gli elementi di una sequenza di input in due sottosequenze
 nelle quali tutti gli elementi della prima sottosequenza sono pi&ugrave; piccoli di
 tutti gli elementi della seconda sottosequenza.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Comparable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Selezione/AlgoritmiSelezione.html#quickSelect(java.lang.Comparable[], int)">quickSelect</A></B>(java.lang.Comparable[]&nbsp;A,
            int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Seleziona l'elemento di ordine k dall'array di input mediante
 un algoritmo di selezione basato su partizionamento (<font color=red>Tempo O(n&sup2;), tempo atteso O(n)</font>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Comparable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Selezione/AlgoritmiSelezione.html#quickSelectRec(java.lang.Comparable[], int, int, int)">quickSelectRec</A></B>(java.lang.Comparable[]&nbsp;A,
               int&nbsp;i,
               int&nbsp;f,
               int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Seleziona l'elemento di ordine k di una sottosequenza di
 elementi dell'array di input.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Comparable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Selezione/AlgoritmiSelezione.html#secondoMinimo(java.lang.Comparable[])">secondoMinimo</A></B>(java.lang.Comparable[]&nbsp;A)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il secondo elemento di chiave minima tra quelli appartenenti
 alla sequenza di input (<font color=red>Tempo O(n)</font>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Comparable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Selezione/AlgoritmiSelezione.html#select(java.lang.Comparable[], int)">select</A></B>(java.lang.Comparable[]&nbsp;A,
       int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Seleziona l'elemento di ordine k dall'array di input mediante
 un algoritmo di selezione basato sul mediano dei mediani (<font color=red>Tempo O(n)</font>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;java.lang.Comparable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Selezione/AlgoritmiSelezione.html#selectRec(java.lang.Comparable[], int, int, int)">selectRec</A></B>(java.lang.Comparable[]&nbsp;A,
          int&nbsp;i,
          int&nbsp;f,
          int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Seleziona l'elemento di ordine k di una sottosequenza dell'array
 di input mediante un algoritmo di selezione basato sul mediano
 dei mediani.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Selezione/AlgoritmiSelezione.html#swap(java.lang.Comparable[], int, int)">swap</A></B>(java.lang.Comparable[]&nbsp;A,
     int&nbsp;i,
     int&nbsp;j)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scambia il contenuto di due diverse posizioni di un array di input.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="AlgoritmiSelezione()"><!-- --></A><H3>
AlgoritmiSelezione</H3>
<PRE>
public <B>AlgoritmiSelezione</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="deleteMin(java.lang.Comparable[], int)"><!-- --></A><H3>
deleteMin</H3>
<PRE>
private static void <B>deleteMin</B>(java.lang.Comparable[]&nbsp;S,
                              int&nbsp;c)</PRE>
<DL>
<DD>Rimuove l'elemento con chiave minima attualmente presente nell'heap. 
 L'operazione viene realizzata sovrascrivendo l'elemento di indice 1 (l'elemento
 di chiave minima) con l'elemento di indice <code>c</code> ed invocando il metodo <code>fixHeap</code>
 per ripristinare la propriet&agrave; di ordinamento dell'heap.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>S</CODE> - l'array usato per rappresentare l'heap<DD><CODE>c</CODE> - il numero di elementi dell'heap</DL>
</DD>
</DL>
<HR>

<A NAME="findMin(java.lang.Comparable[])"><!-- --></A><H3>
findMin</H3>
<PRE>
private static java.lang.Comparable <B>findMin</B>(java.lang.Comparable[]&nbsp;S)</PRE>
<DL>
<DD>Restituisce l'elemento di chiave minima attualmente custodito nell'heap.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>S</CODE> - l'array usato per rappresentare l'heap
<DT><B>Returns:</B><DD>l'elemento di chiave minima custodito nell'heap
<DT><B>Throws:</B>
<DD><CODE>ArrayOutOfBoundsException</CODE> - se l'heap &egrave; vuoto</DL>
</DD>
</DL>
<HR>

<A NAME="fixHeap(java.lang.Comparable[], int, int)"><!-- --></A><H3>
fixHeap</H3>
<PRE>
private static void <B>fixHeap</B>(java.lang.Comparable[]&nbsp;S,
                            int&nbsp;c,
                            int&nbsp;i)</PRE>
<DL>
<DD>Ripristina la propriet&agrave; di ordinamento di un heap rispetto
 ad un nodo di indice <code>i</code>. L'operazione avviene confrontando ricorsivamente
 il nodo di indice i con i suoi figli ed operando uno scambio di nodi
 ogni qual volta la propriet&agrave; di ordinamento non sia verificata.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>S</CODE> - l'array utilizzato per rappresentare l'heap<DD><CODE>c</CODE> - il numero di elementi dell'heap<DD><CODE>i</CODE> - l'indice dell'elemento su cui verificare la propriet&agrave; di ordinamento dell'heap</DL>
</DD>
</DL>
<HR>

<A NAME="heapify(java.lang.Comparable[], int, int)"><!-- --></A><H3>
heapify</H3>
<PRE>
private static void <B>heapify</B>(java.lang.Comparable[]&nbsp;S,
                            int&nbsp;n,
                            int&nbsp;i)</PRE>
<DL>
<DD>Trasforma in heap un array di elementi a partire da un elemento
 di indice <code>i</code>. La trasformazione avviene invocando ricorsivamente il metodo
 <code>heapify</code> per la trasformazione dei figli del nodo di indice <code>i</code>,
 ed il metodo <code>fixHeap</code> sul nodo di indice <code>i</code> per il ripristino della propriet&agrave;
 di ordinamento dell'heap.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>S</CODE> - l'array da trasformare in heap<DD><CODE>n</CODE> - il numero di elementi dell'array<DD><CODE>i</CODE> - l'indice dell'elemento dell'array da cui innescare la trasformazione</DL>
</DD>
</DL>
<HR>

<A NAME="heapSelect(java.lang.Comparable[], int)"><!-- --></A><H3>
heapSelect</H3>
<PRE>
public static java.lang.Comparable <B>heapSelect</B>(java.lang.Comparable[]&nbsp;A,
                                              int&nbsp;k)</PRE>
<DL>
<DD>Seleziona l'elemento di ordine k dall'array di input mediante
 l'uso di un heap (<font color=red>Tempo O(n + k&middot;log(n))</font>). La selezione viene effettuata trasformando
 l'array di input in heap, attraverso il metodo <code>heapify</code>,
 ed eseguendo k operazioni di estrazione dell'elemento
 con chiave mimina (<code>deleteMin</code>).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array di cui ricercare l'elemento di ordine <code>k</code><DD><CODE>k</CODE> - l'ordine dell'elemento che si intende selezionare
<DT><B>Returns:</B><DD>l'elemento di <code>A</code> di ordine <code>k</code></DL>
</DD>
</DL>
<HR>

<A NAME="med3(java.lang.Comparable[], int)"><!-- --></A><H3>
med3</H3>
<PRE>
private static java.lang.Comparable <B>med3</B>(java.lang.Comparable[]&nbsp;A,
                                         int&nbsp;i)</PRE>
<DL>
<DD>Restituisce l'elemento mediano di una sottosequenza di lunghezza 3
 della sequenza di input utilizzando due confronti.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - la sequenza contenente la sottosequenza di cui si vuole conoscere l'elemento mediano<DD><CODE>i</CODE> - l'indice del primo elemento della sottosequenza di 3 elementi
<DT><B>Returns:</B><DD>l'elemento mediano</DL>
</DD>
</DL>
<HR>

<A NAME="med4(java.lang.Comparable[], int)"><!-- --></A><H3>
med4</H3>
<PRE>
private static java.lang.Comparable <B>med4</B>(java.lang.Comparable[]&nbsp;A,
                                         int&nbsp;i)</PRE>
<DL>
<DD>Restituisce l'elemento mediano di una sottosequenza di lunghezza 4
 della sequenza di input utilizzando al pi&ugrave; tre confronti.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - la sequenza contenente la sottosequenza di cui si vuole conoscere l'elemento mediano<DD><CODE>i</CODE> - l'indice del primo elemento della sottosequenza di 4 elementi
<DT><B>Returns:</B><DD>l'elemento mediano</DL>
</DD>
</DL>
<HR>

<A NAME="med5(java.lang.Comparable[], int)"><!-- --></A><H3>
med5</H3>
<PRE>
private static java.lang.Comparable <B>med5</B>(java.lang.Comparable[]&nbsp;A,
                                         int&nbsp;i)</PRE>
<DL>
<DD>Restituisce l'elemento mediano di una sottosequenza di lunghezza 5
 della sequenza di input utilizzando al pi&ugrave; sei confronti.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - la sequenza contenente la sottosequenza di cui si vuole conoscere l'elemento mediano<DD><CODE>i</CODE> - l'indice del primo elemento della sottosequenza di 5 elementi
<DT><B>Returns:</B><DD>l'elemento mediano</DL>
</DD>
</DL>
<HR>

<A NAME="minimo(java.lang.Comparable[])"><!-- --></A><H3>
minimo</H3>
<PRE>
public static java.lang.Comparable <B>minimo</B>(java.lang.Comparable[]&nbsp;A)</PRE>
<DL>
<DD>Restituisce l'elemento di chiave minima tra quelli appartenenti
 alla sequenza di input (<font color=red>Tempo O(n)</font>). L'elemento minimo viene determinato 
 in base ad una scansione lineare dell'array di input.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array di cui ricercare l'elemento minimo
<DT><B>Returns:</B><DD>l'elemento di <code>A</code> con chiave minima</DL>
</DD>
</DL>
<HR>

<A NAME="partition(java.lang.Comparable[], int, int)"><!-- --></A><H3>
partition</H3>
<PRE>
private static int <B>partition</B>(java.lang.Comparable[]&nbsp;A,
                             int&nbsp;i,
                             int&nbsp;f)</PRE>
<DL>
<DD>Partiziona <em>in loco</em> gli elementi di una sequenza di input in due sottosequenze
 nelle quali tutti gli elementi della prima sottosequenza sono pi&ugrave; piccoli di
 tutti gli elementi della seconda sottosequenza. L'effettivo partizionamento
 viene demandato al secondo metodo <code>partition</code> cui viene fornito
 anche l'indice dell'elemento che funger&agrave; da perno. L'elemento perno viene scelto
 come elemento casuale all'interno della sequenza da ordinare.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array contenente la sottosequenza da ordinare<DD><CODE>i</CODE> - l'indice dell'estremo inferiore della sottosequenza da ordinare<DD><CODE>f</CODE> - l'indice dell'estremo superiore della sottosequenza da ordinare
<DT><B>Returns:</B><DD>la posizione dell'elemento perno nella sequenza partizionata</DL>
</DD>
</DL>
<HR>

<A NAME="partition(java.lang.Comparable[], int, int, int)"><!-- --></A><H3>
partition</H3>
<PRE>
public static int <B>partition</B>(java.lang.Comparable[]&nbsp;A,
                            int&nbsp;i,
                            int&nbsp;f,
                            int&nbsp;pos)</PRE>
<DL>
<DD>Partiziona <em>in loco</em> gli elementi di una sequenza di input in due sottosequenze
 nelle quali tutti gli elementi della prima sottosequenza sono pi&ugrave; piccoli di
 tutti gli elementi della seconda sottosequenza. L'indice dell'elemento
 perno viene indicato da input.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array contenente la sottosequenza da ordinare<DD><CODE>i</CODE> - l'indice dell'estremo inferiore della sottosequenza da ordinare<DD><CODE>f</CODE> - l'indice dell'estremo superiore della sottosequenza da ordinare<DD><CODE>pos</CODE> - l'indice dell'elemento perno
<DT><B>Returns:</B><DD>la posizione dell'elemento perno nella sequenza partizionata</DL>
</DD>
</DL>
<HR>

<A NAME="quickSelect(java.lang.Comparable[], int)"><!-- --></A><H3>
quickSelect</H3>
<PRE>
public static java.lang.Comparable <B>quickSelect</B>(java.lang.Comparable[]&nbsp;A,
                                               int&nbsp;k)</PRE>
<DL>
<DD>Seleziona l'elemento di ordine k dall'array di input mediante
 un algoritmo di selezione basato su partizionamento (<font color=red>Tempo O(n&sup2;), tempo atteso O(n)</font>). La selezione
 avviene invocando il metodo ricorsivo <code>quickSelectRec</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array di cui ricercare l'elemento di ordine <code>k</code><DD><CODE>k</CODE> - l'ordine dell'elemento che si intende selezionare
<DT><B>Returns:</B><DD>l'elemento di <code>A</code> di ordine <code>k</code></DL>
</DD>
</DL>
<HR>

<A NAME="quickSelectRec(java.lang.Comparable[], int, int, int)"><!-- --></A><H3>
quickSelectRec</H3>
<PRE>
public static java.lang.Comparable <B>quickSelectRec</B>(java.lang.Comparable[]&nbsp;A,
                                                  int&nbsp;i,
                                                  int&nbsp;f,
                                                  int&nbsp;k)</PRE>
<DL>
<DD>Seleziona l'elemento di ordine k di una sottosequenza di
 elementi dell'array di input. La selezione avviene innanzitutto
 partizionando, mediante il metodo <code>partition</code>,
 la sottosequenza di input in tre parti. Dopodich&eacute;, valuta
 quale delle tre parti contiene l'elemento di ordine k ed,
 eventualmente, opera una ulteriore chiamata ricorsiva
 del metodo <code>quickSelectRec</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array di cui ricercare l'elemento di ordine <code>k</code><DD><CODE>i</CODE> - l'indice dell'estremo inferiore della sequenza su cui operare la selezione<DD><CODE>f</CODE> - l'indice dell'estremo superiore della sequenza su cui operare la selezione<DD><CODE>k</CODE> - l'ordine dell'elemento che si intende selezionare
<DT><B>Returns:</B><DD>l'elemento di <code>A</code> di ordine <code>k</code></DL>
</DD>
</DL>
<HR>

<A NAME="secondoMinimo(java.lang.Comparable[])"><!-- --></A><H3>
secondoMinimo</H3>
<PRE>
public static java.lang.Comparable <B>secondoMinimo</B>(java.lang.Comparable[]&nbsp;A)</PRE>
<DL>
<DD>Restituisce il secondo elemento di chiave minima tra quelli appartenenti
 alla sequenza di input (<font color=red>Tempo O(n)</font>). L'elemento minimo viene determinato 
 in base ad una scansione lineare dell'array di input.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array di cui ricercare il secondo elemento minimo
<DT><B>Returns:</B><DD>il secondo elemento di <code>A</code> con chiave minima</DL>
</DD>
</DL>
<HR>

<A NAME="select(java.lang.Comparable[], int)"><!-- --></A><H3>
select</H3>
<PRE>
public static java.lang.Comparable <B>select</B>(java.lang.Comparable[]&nbsp;A,
                                          int&nbsp;k)</PRE>
<DL>
<DD>Seleziona l'elemento di ordine k dall'array di input mediante
 un algoritmo di selezione basato sul mediano dei mediani (<font color=red>Tempo O(n)</font>). 
 La selezione avviene invocando il metodo ricorsivo <code>selectRec</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array di cui ricercare l'elemento di ordine <code>k</code><DD><CODE>k</CODE> - l'ordine dell'elemento che si intende selezionare
<DT><B>Returns:</B><DD>l'elemento di <code>A</code> di ordine <code>k</code></DL>
</DD>
</DL>
<HR>

<A NAME="selectRec(java.lang.Comparable[], int, int, int)"><!-- --></A><H3>
selectRec</H3>
<PRE>
private static java.lang.Comparable <B>selectRec</B>(java.lang.Comparable[]&nbsp;A,
                                              int&nbsp;i,
                                              int&nbsp;f,
                                              int&nbsp;k)</PRE>
<DL>
<DD>Seleziona l'elemento di ordine k di una sottosequenza dell'array
 di input mediante un algoritmo di selezione basato sul mediano
 dei mediani. L'algoritmo opera:
 <ul>
 <li> suddividendo la sottosequenza di input in gruppi aventi al pi&ugrave; 5 elementi </li>
 <li> calcolando, con l'eventuale ausilio dei metodi <code>med3</code>, <code>med4</code> e <code>med5</code>, i mediani
 di ciascun gruppo </li>
 <li> calcolando, mediante il metodo <code>select</code>, il mediano dei mediani precedentemente calcolati</li>
 <li> partizionando la sottosequenza di input mediante il metodo <code>partition</code> utilizzando come perno
 il mediano dei mediani </li>
 <li> invocando, eventualmente, lo stesso metodo ricorsivo <code>selectRec</code> su una delle sottosequenze
 determinate dal metodo <code>partition</code></li>
 </ul>
 Nel caso in cui la taglia della sottosequenza di input su cui operare la selezione sia inferiore a 10, il metodo
 utilizza il metodo <code>quickSortRec</code> per ordinare la sottosequenza di input e determinare direttamente
 l'elemento di ordine k ricercato
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array di cui ricercare l'elemento di ordine <code>k</code><DD><CODE>i</CODE> - l'indice dell'estremo inferiore della sequenza su cui operare la selezione<DD><CODE>f</CODE> - l'indice dell'estremo superiore della sequenza su cui operare la selezione<DD><CODE>k</CODE> - l'ordine dell'elemento che si intende selezionare
<DT><B>Returns:</B><DD>l'elemento di <code>A</code> di ordine <code>k</code></DL>
</DD>
</DL>
<HR>

<A NAME="swap(java.lang.Comparable[], int, int)"><!-- --></A><H3>
swap</H3>
<PRE>
private static void <B>swap</B>(java.lang.Comparable[]&nbsp;A,
                         int&nbsp;i,
                         int&nbsp;j)</PRE>
<DL>
<DD>Scambia il contenuto di due diverse posizioni di un array di input.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array in cui operare lo scambio<DD><CODE>i</CODE> - l'indice del primo elemento da scambiare<DD><CODE>j</CODE> - l'indice del secondo elemento da scambiare</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AlgoritmiSelezione.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?asdlab/libreria/Selezione/AlgoritmiSelezione.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="AlgoritmiSelezione.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
