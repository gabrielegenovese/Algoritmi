<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_07) on Tue Apr 17 10:32:36 CEST 2007 -->
<TITLE>
AlgoritmiOrdinamento
</TITLE>

<META NAME="keywords" CONTENT="asdlab.libreria.Ordinamento.AlgoritmiOrdinamento class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="AlgoritmiOrdinamento";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AlgoritmiOrdinamento.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="AlgoritmiOrdinamento.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
asdlab.libreria.Ordinamento</FONT>
<BR>
Class AlgoritmiOrdinamento</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>asdlab.libreria.Ordinamento.AlgoritmiOrdinamento</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>AlgoritmiOrdinamento</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
La classe <code>AlgoritmiOrdinamento</code> contiene l'implementazione di diversi
 algoritmi per l'ordinamento di collezioni di oggetti. Sono implementati sia algoritmi basati
 su confronti, quali <code>selectionSort</code>, <code>bubbleSort</code>, <code>heapSort</code>,
 <code>mergeSort</code>, <code>quickSort</code> che algoritmi capaci di operare, sotto opportune
 ipotesi, in tempo lineare, quali <code>bucketSort</code>, <code>radixSort</code> e <code>integerSort</code>.
 <br>
 Tutte le implementazioni proposte assumono che l'input sia costituito da un array i cui
 elementi implementano l'interfaccia standard <code>Comparable</code>. La sequenza ordinata
 viene prodotta da ciascun algoritmo nello stesso array utilizzato per indicare la sequenza di input.
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html#AlgoritmiOrdinamento()">AlgoritmiOrdinamento</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html#bubbleSort(java.lang.Comparable[])">bubbleSort</A></B>(java.lang.Comparable[]&nbsp;A)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ordina <em>in loco </em> l'array di input utilizzando l'algoritmo di bubble sort (<font color=red>Tempo O(n&sup2;)</font>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html#bucketSort(int[], int, int)">bucketSort</A></B>(int[]&nbsp;A,
           int&nbsp;b,
           int&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ordina l'array di input utilizzando l'algoritmo di bucket sort (<font color=red>Tempo O(n + b)</font>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html#deleteMax(java.lang.Comparable[], int)">deleteMax</A></B>(java.lang.Comparable[]&nbsp;S,
          int&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rimuove l'elemento con chiave massima attualmente presente nell'heap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;java.lang.Comparable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html#findMax(java.lang.Comparable[])">findMax</A></B>(java.lang.Comparable[]&nbsp;S)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'elemento di chiave massima attualmente custodito nell'heap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html#fixHeap(java.lang.Comparable[], int, int)">fixHeap</A></B>(java.lang.Comparable[]&nbsp;S,
        int&nbsp;c,
        int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ripristina la propriet&agrave; di ordinamento di un heap rispetto
 ad un nodo di indice <code>i</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html#heapify(java.lang.Comparable[], int, int)">heapify</A></B>(java.lang.Comparable[]&nbsp;S,
        int&nbsp;n,
        int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trasforma in heap un array di elementi a partire da un elemento
 di indice <code>i</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html#heapSort(java.lang.Comparable[])">heapSort</A></B>(java.lang.Comparable[]&nbsp;S)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ordina <em>in loco </em> l'array di input
 utilizzando l'algoritmo di heap sort (<font color=red>Tempo O(n&middot;log(n))</font>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html#insertionSort(java.lang.Comparable[])">insertionSort</A></B>(java.lang.Comparable[]&nbsp;A)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ordina <em>in loco </em> l'array di input utilizzando l'algoritmo di insertion sort (<font color=red>Tempo O(n&sup2;)</font>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html#integerSort(int[], int)">integerSort</A></B>(int[]&nbsp;A,
            int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ordina l'array di input utilizzando l'algoritmo di integer sort (<font color=red>Tempo O(n+k)</font>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html#merge(java.lang.Comparable[], int, int, int)">merge</A></B>(java.lang.Comparable[]&nbsp;A,
      int&nbsp;i1,
      int&nbsp;f1,
      int&nbsp;f2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fonde due sottosequenze di elementi consecutive appartenenti
 ad uno stesso array di input in un'unica sequenza ordinata.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html#mergeSort(java.lang.Comparable[])">mergeSort</A></B>(java.lang.Comparable[]&nbsp;A)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ordina <em>in loco </em> l'array di input utilizzando l'algoritmo di merge sort (<font color=red>Tempo O(n&middot;log(n))</font>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html#mergeSortRec(java.lang.Comparable[], int, int)">mergeSortRec</A></B>(java.lang.Comparable[]&nbsp;A,
             int&nbsp;i,
             int&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ordina <em>in loco </em> una porzione dell'array di input
 utilizzando l'algoritmo di merge sort.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html#partition(java.lang.Comparable[], int, int)">partition</A></B>(java.lang.Comparable[]&nbsp;A,
          int&nbsp;i,
          int&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Partiziona <em>in loco</em> gli elementi di una sequenza di input in due sottosequenze
 nelle quali tutti gli elementi della prima sottosequenza sono pi&ugrave; piccoli di
 tutti gli elementi della seconda sottosequenza.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html#quickSort(java.lang.Comparable[])">quickSort</A></B>(java.lang.Comparable[]&nbsp;A)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ordina <em>in loco </em> l'array di input utilizzando l'algoritmo di quick sort (<font color=red>Tempo O(n&sup2;), tempo atteso O(n&middot;log(n)</font>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html#quickSortRec(java.lang.Comparable[], int, int)">quickSortRec</A></B>(java.lang.Comparable[]&nbsp;A,
             int&nbsp;i,
             int&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ordina <em>in loco </em> una porzione dell'array di input
 utilizzando l'algoritmo di quick sort.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html#radixSort(int[], int, int)">radixSort</A></B>(int[]&nbsp;A,
          int&nbsp;k,
          int&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ordina l'array di input utilizzando l'algoritmo di radix sort (<font color=red>Tempo O(n&middot;(1 + log(k)/log(n)))</font>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html#selectionSort(java.lang.Comparable[])">selectionSort</A></B>(java.lang.Comparable[]&nbsp;A)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ordina <em>in loco </em> l'array di input utilizzando l'algoritmo di selection sort (<font color=red>Tempo O(n&sup2;)</font>).</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="AlgoritmiOrdinamento()"><!-- --></A><H3>
AlgoritmiOrdinamento</H3>
<PRE>
public <B>AlgoritmiOrdinamento</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="bubbleSort(java.lang.Comparable[])"><!-- --></A><H3>
bubbleSort</H3>
<PRE>
public static void <B>bubbleSort</B>(java.lang.Comparable[]&nbsp;A)</PRE>
<DL>
<DD>Ordina <em>in loco </em> l'array di input utilizzando l'algoritmo di bubble sort (<font color=red>Tempo O(n&sup2;)</font>).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array da ordinare</DL>
</DD>
</DL>
<HR>

<A NAME="bucketSort(int[], int, int)"><!-- --></A><H3>
bucketSort</H3>
<PRE>
public static void <B>bucketSort</B>(int[]&nbsp;A,
                              int&nbsp;b,
                              int&nbsp;t)</PRE>
<DL>
<DD>Ordina l'array di input utilizzando l'algoritmo di bucket sort (<font color=red>Tempo O(n + b)</font>).
 L'ordinamento avviene rispetto alla <code>t</code>-sima cifra della rappresentazione
 in base <code>b</code> degli elementi dell'array di input <code>A</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array da ordinare<DD><CODE>b</CODE> - la base rispetto cui decomporre la rappresentazione degli elementi di <code>A</code><DD><CODE>t</CODE> - l'indice della cifra della rappresentazione in base <code>b</code> degli elementi
 di <code>A</code> su cui fare perno durante l'ordinamento</DL>
</DD>
</DL>
<HR>

<A NAME="deleteMax(java.lang.Comparable[], int)"><!-- --></A><H3>
deleteMax</H3>
<PRE>
private static void <B>deleteMax</B>(java.lang.Comparable[]&nbsp;S,
                              int&nbsp;c)</PRE>
<DL>
<DD>Rimuove l'elemento con chiave massima attualmente presente nell'heap. 
 L'operazione viene realizzata sovrascrivendo l'elemento di indice 1 (l'elemento
 di chiave massima) con l'elemento di indice <code>c</code> ed invocando il metodo <code>fixHeap</code>
 per ripristinare la propriet&agrave; di ordinamento dell'heap
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>S</CODE> - l'array usato per rappresentare l'heap<DD><CODE>c</CODE> - il numero di elementi dell'heap</DL>
</DD>
</DL>
<HR>

<A NAME="findMax(java.lang.Comparable[])"><!-- --></A><H3>
findMax</H3>
<PRE>
private static java.lang.Comparable <B>findMax</B>(java.lang.Comparable[]&nbsp;S)</PRE>
<DL>
<DD>Restituisce l'elemento di chiave massima attualmente custodito nell'heap.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>S</CODE> - l'array usato per rappresentare l'heap
<DT><B>Returns:</B><DD>l'elemento di chiave massima custodito nell'heap
<DT><B>Throws:</B>
<DD><CODE>ArrayOutOfBoundsException</CODE> - se l'heap &egrave; vuoto</DL>
</DD>
</DL>
<HR>

<A NAME="fixHeap(java.lang.Comparable[], int, int)"><!-- --></A><H3>
fixHeap</H3>
<PRE>
private static void <B>fixHeap</B>(java.lang.Comparable[]&nbsp;S,
                            int&nbsp;c,
                            int&nbsp;i)</PRE>
<DL>
<DD>Ripristina la propriet&agrave; di ordinamento di un heap rispetto
 ad un nodo di indice <code>i</code>. L'operazione avviene confrontando ricorsivamente
 il nodo di indice i con i suoi figli ed operando uno scambio di nodi
 ogni qual volta la propriet&agrave; di ordinamento non sia verificata.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>S</CODE> - l'array utilizzato per rappresentare l'heap<DD><CODE>c</CODE> - il numero di elementi dell'heap<DD><CODE>i</CODE> - l'indice dell'elemento su cui verificare la propriet&agrave; di ordinamento dell'heap</DL>
</DD>
</DL>
<HR>

<A NAME="heapify(java.lang.Comparable[], int, int)"><!-- --></A><H3>
heapify</H3>
<PRE>
private static void <B>heapify</B>(java.lang.Comparable[]&nbsp;S,
                            int&nbsp;n,
                            int&nbsp;i)</PRE>
<DL>
<DD>Trasforma in heap un array di elementi a partire da un elemento
 di indice <code>i</code>. La trasformazione avviene invocando ricorsivamente il metodo
 <code>heapify</code> per la trasformazione dei figli del nodo di indice <code>i</code>,
 ed il metodo <code>fixHeap</code> sul nodo di indice <code>i</code> per il ripristino della propriet&agrave; 
 di ordinamento dell'heap
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>S</CODE> - l'array da trasformare in heap<DD><CODE>n</CODE> - il numero di elementi dell'array<DD><CODE>i</CODE> - l'indice dell'elemento dell'array da cui innescare la trasformazione</DL>
</DD>
</DL>
<HR>

<A NAME="heapSort(java.lang.Comparable[])"><!-- --></A><H3>
heapSort</H3>
<PRE>
public static void <B>heapSort</B>(java.lang.Comparable[]&nbsp;S)</PRE>
<DL>
<DD>Ordina <em>in loco </em> l'array di input
 utilizzando l'algoritmo di heap sort (<font color=red>Tempo O(n&middot;log(n))</font>). L'ordinamento
 avviene trasformando l'array di input in un heap, 
 attraverso il metodo <code>heapify</code>, e determinando gli elementi della sequenza ordinata
 attraverso i metodi <code>findMax</code> e <code>deleteMax</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>S</CODE> - l'array da ordinare</DL>
</DD>
</DL>
<HR>

<A NAME="insertionSort(java.lang.Comparable[])"><!-- --></A><H3>
insertionSort</H3>
<PRE>
public static void <B>insertionSort</B>(java.lang.Comparable[]&nbsp;A)</PRE>
<DL>
<DD>Ordina <em>in loco </em> l'array di input utilizzando l'algoritmo di insertion sort (<font color=red>Tempo O(n&sup2;)</font>).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array da ordinare</DL>
</DD>
</DL>
<HR>

<A NAME="integerSort(int[], int)"><!-- --></A><H3>
integerSort</H3>
<PRE>
public static void <B>integerSort</B>(int[]&nbsp;A,
                               int&nbsp;k)</PRE>
<DL>
<DD>Ordina l'array di input utilizzando l'algoritmo di integer sort (<font color=red>Tempo O(n+k)</font>).
 Assume che gli elementi dell'array abbiano tutti valore nell'intervallo
 [0, k - 1], dove k &egrave; indicato da input.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array da ordinare<DD><CODE>k</CODE> - il valore massimo assumibile dagli elementi di <code>A</code>
<DT><B>Throws:</B>
<DD><CODE>ArrayOutOfBoundsException</CODE> - se <code>A</code> contiene elementi il cui valore non &egrave; incluso nell'intervallo [0, k - 1]</DL>
</DD>
</DL>
<HR>

<A NAME="merge(java.lang.Comparable[], int, int, int)"><!-- --></A><H3>
merge</H3>
<PRE>
private static void <B>merge</B>(java.lang.Comparable[]&nbsp;A,
                          int&nbsp;i1,
                          int&nbsp;f1,
                          int&nbsp;f2)</PRE>
<DL>
<DD>Fonde due sottosequenze di elementi consecutive appartenenti
 ad uno stesso array di input in un'unica sequenza ordinata.
 La sequenza prodotta dalla fusione viene collocata nelle
 posizioni originariamente occupate dalle due sottosequenze.
 Assume che gli elementi delle due sottosequenze siano
 ordinati
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array contenente le sottosequenze da ordinare<DD><CODE>i1</CODE> - l'indice dell'estremo inferiore della prima sottosequenza<DD><CODE>f1</CODE> - l'indice dell'estremo superiore della prima sottosequenza<DD><CODE>f2</CODE> - l'indice dell'estremo superiore della seconda sottosequenza</DL>
</DD>
</DL>
<HR>

<A NAME="mergeSort(java.lang.Comparable[])"><!-- --></A><H3>
mergeSort</H3>
<PRE>
public static void <B>mergeSort</B>(java.lang.Comparable[]&nbsp;A)</PRE>
<DL>
<DD>Ordina <em>in loco </em> l'array di input utilizzando l'algoritmo di merge sort (<font color=red>Tempo O(n&middot;log(n))</font>).
 L'ordinamento avviene richiamando internamente il metodo ricorsivo <code>mergeSortRec</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array da ordinare</DL>
</DD>
</DL>
<HR>

<A NAME="mergeSortRec(java.lang.Comparable[], int, int)"><!-- --></A><H3>
mergeSortRec</H3>
<PRE>
private static void <B>mergeSortRec</B>(java.lang.Comparable[]&nbsp;A,
                                 int&nbsp;i,
                                 int&nbsp;f)</PRE>
<DL>
<DD>Ordina <em>in loco </em> una porzione dell'array di input
 utilizzando l'algoritmo di merge sort.
 L'ordinamento avviene richiamando ricorsivamente lo stesso metodo
 <code>mergeSortRec</code>, per l'ordinamento di sottosequenze di <code>A</code>, ed il metodo
 <code>merge</code>, per la fusione di sottosequenze ordinate.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array da ordinare<DD><CODE>i</CODE> - l'indice dell'estremo inferiore della sequenza da ordinare<DD><CODE>f</CODE> - l'indice dell'estremo superiore della sequenza da ordinare</DL>
</DD>
</DL>
<HR>

<A NAME="partition(java.lang.Comparable[], int, int)"><!-- --></A><H3>
partition</H3>
<PRE>
private static int <B>partition</B>(java.lang.Comparable[]&nbsp;A,
                             int&nbsp;i,
                             int&nbsp;f)</PRE>
<DL>
<DD>Partiziona <em>in loco</em> gli elementi di una sequenza di input in due sottosequenze
 nelle quali tutti gli elementi della prima sottosequenza sono pi&ugrave; piccoli di
 tutti gli elementi della seconda sottosequenza. L'elemento perno viene scelto
 come elemento casuale all'interno della sequenza da ordinare.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array contenente la sottosequenza da ordinare<DD><CODE>i</CODE> - l'indice dell'estremo inferiore della sottosequenza da ordinare<DD><CODE>f</CODE> - l'indice dell'estremo superiore della sottosequenza da ordinare
<DT><B>Returns:</B><DD>la posizione dell'elemento perno nella sequenza partizionata</DL>
</DD>
</DL>
<HR>

<A NAME="quickSort(java.lang.Comparable[])"><!-- --></A><H3>
quickSort</H3>
<PRE>
public static void <B>quickSort</B>(java.lang.Comparable[]&nbsp;A)</PRE>
<DL>
<DD>Ordina <em>in loco </em> l'array di input utilizzando l'algoritmo di quick sort (<font color=red>Tempo O(n&sup2;), tempo atteso O(n&middot;log(n)</font>).
 L'ordinamento avviene richiamando internamente il metodo ricorsivo <code>quickSortRec</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array da ordinare</DL>
</DD>
</DL>
<HR>

<A NAME="quickSortRec(java.lang.Comparable[], int, int)"><!-- --></A><H3>
quickSortRec</H3>
<PRE>
public static void <B>quickSortRec</B>(java.lang.Comparable[]&nbsp;A,
                                int&nbsp;i,
                                int&nbsp;f)</PRE>
<DL>
<DD>Ordina <em>in loco </em> una porzione dell'array di input
 utilizzando l'algoritmo di quick sort.
 L'ordinamento avviene invocando il metodo <code>partition</code> 
 per dividere la sequenza da ordinare in due sottosequenze
 nelle quali tutti gli elementi della prima sottosequenza sono pi&ugrave;
 piccoli di tutti gli elementi della seconda sottosequenza. 
 Le due sottosequenze sono a loro volta ordinate mediate una chiamata ricorsiva
 dello stesso metodo <code>quickSortRec</code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array da ordinare<DD><CODE>i</CODE> - l'indice dell'estremo inferiore della sequenza da ordinare<DD><CODE>f</CODE> - l'indice dell'estremo superiore della sequenza da ordinare</DL>
</DD>
</DL>
<HR>

<A NAME="radixSort(int[], int, int)"><!-- --></A><H3>
radixSort</H3>
<PRE>
public static void <B>radixSort</B>(int[]&nbsp;A,
                             int&nbsp;k,
                             int&nbsp;b)</PRE>
<DL>
<DD>Ordina l'array di input utilizzando l'algoritmo di radix sort (<font color=red>Tempo O(n&middot;(1 + log(k)/log(n)))</font>).
 Assume che gli elementi dell'array <code>A</code> abbiano tutti valore nell'intervallo
 [0, k - 1], dove k &egrave; indicato da input. L'ordinamento avviene
 applicando reiteratamente l'algoritmo di <code>bucketSort</code> sulle diverse cifre
 che compongono la rappresentazione in base <code>b</code> degli elementi di <code>A</code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array da ordinare<DD><CODE>k</CODE> - il valore massimo assumibile dagli elementi di <code>A</code><DD><CODE>b</CODE> - la base rispetto cui decomporre la rappresentazione degli elementi di <code>A</code></DL>
</DD>
</DL>
<HR>

<A NAME="selectionSort(java.lang.Comparable[])"><!-- --></A><H3>
selectionSort</H3>
<PRE>
public static void <B>selectionSort</B>(java.lang.Comparable[]&nbsp;A)</PRE>
<DL>
<DD>Ordina <em>in loco </em> l'array di input utilizzando l'algoritmo di selection sort (<font color=red>Tempo O(n&sup2;)</font>).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - l'array da ordinare</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AlgoritmiOrdinamento.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?asdlab/libreria/Ordinamento/AlgoritmiOrdinamento.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="AlgoritmiOrdinamento.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
